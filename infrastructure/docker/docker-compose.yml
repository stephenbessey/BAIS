# ============================================================================
# BAIS Platform - Docker Compose Configuration
# Best practices: Service Isolation, Clear Dependencies, Environment Management
# ============================================================================

version: '3.8'

services:
  # BAIS Application
  app:
    build:
      context: ../../
      dockerfile: infrastructure/docker/Dockerfile
    container_name: bais-app
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://bais_user:changeme@postgres:5432/bais_production
      - REDIS_URL=redis://redis-cluster:6379
      - SECRET_KEY=${SECRET_KEY:-dev-secret-key-change-in-production}
      - LOG_LEVEL=${LOG_LEVEL:-INFO}
      - WORKERS=4
      - TIMEOUT=120
    depends_on:
      postgres:
        condition: service_healthy
      redis-cluster:
        condition: service_started
    networks:
      - bais-network
    volumes:
      - app-logs:/app/logs
      - app-tmp:/app/tmp
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '2'
          memory: 4G
        reservations:
          cpus: '1'
          memory: 2G
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
        window: 120s
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # PostgreSQL Database
  postgres:
    image: postgres:15.4-alpine
    container_name: bais-postgres
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_DB=bais_production
      - POSTGRES_USER=bais_user
      - POSTGRES_PASSWORD=${DB_PASSWORD:-changeme}
      - POSTGRES_MAX_CONNECTIONS=1000
      - POSTGRES_SHARED_BUFFERS=4GB
      - POSTGRES_EFFECTIVE_CACHE_SIZE=12GB
      - POSTGRES_MAINTENANCE_WORK_MEM=1GB
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./postgres-init:/docker-entrypoint-initdb.d
      - postgres-logs:/var/log/postgresql
    networks:
      - bais-network
    deploy:
      resources:
        limits:
          cpus: '4'
          memory: 8G
        reservations:
          cpus: '2'
          memory: 4G
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U bais_user -d bais_production"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    command: >
      postgres
      -c shared_buffers=4GB
      -c effective_cache_size=12GB
      -c maintenance_work_mem=1GB
      -c checkpoint_completion_target=0.9
      -c wal_buffers=16MB
      -c default_statistics_target=100
      -c random_page_cost=1.1
      -c effective_io_concurrency=200
      -c work_mem=10MB
      -c min_wal_size=2GB
      -c max_wal_size=8GB

  # Redis Cluster (Single node for development)
  redis-cluster:
    image: redis:7.2-alpine
    container_name: bais-redis
    ports:
      - "6379:6379"
    command: >
      redis-server
      --appendonly yes
      --appendfsync everysec
      --maxmemory 2gb
      --maxmemory-policy allkeys-lru
      --save 900 1
      --save 300 10
      --save 60 10000
      --cluster-enabled yes
      --cluster-config-file nodes.conf
      --cluster-node-timeout 5000
    volumes:
      - redis-data:/data
      - redis-logs:/var/log/redis
    networks:
      - bais-network
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 4G
        reservations:
          cpus: '1'
          memory: 2G
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 20s

  # Redis Cluster Initialization (for production-like setup)
  redis-init:
    image: redis:7.2-alpine
    container_name: bais-redis-init
    depends_on:
      redis-cluster:
        condition: service_healthy
    networks:
      - bais-network
    command: >
      sh -c "
        echo 'Waiting for Redis to be ready...'
        until redis-cli -h redis-cluster ping; do sleep 1; done
        echo 'Redis is ready'
        # In production, this would initialize a 6-node cluster
        echo 'Redis cluster initialization completed'
      "
    deploy:
      restart_policy:
        condition: on-failure
        max_attempts: 3

  # Prometheus Monitoring
  prometheus:
    image: prom/prometheus:latest
    container_name: bais-prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus-data:/prometheus
    networks:
      - bais-network
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=15d'
      - '--web.enable-lifecycle'
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 2G
        reservations:
          cpus: '500m'
          memory: 1G

  # Grafana Dashboard
  grafana:
    image: grafana/grafana:latest
    container_name: bais-grafana
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD:-admin}
      - GF_INSTALL_PLUGINS=grafana-clock-panel,grafana-simple-json-datasource
    volumes:
      - grafana-data:/var/lib/grafana
      - ./grafana-dashboards:/etc/grafana/provisioning/dashboards
      - ./grafana-datasources:/etc/grafana/provisioning/datasources
    networks:
      - bais-network
    depends_on:
      - prometheus
    deploy:
      resources:
        limits:
          cpus: '500m'
          memory: 1G
        reservations:
          cpus: '250m'
          memory: 512M

  # Elasticsearch (for log aggregation)
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.10.0
    container_name: bais-elasticsearch
    ports:
      - "9200:9200"
      - "9300:9300"
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
      - "ES_JAVA_OPTS=-Xms1g -Xmx1g"
    volumes:
      - elasticsearch-data:/usr/share/elasticsearch/data
    networks:
      - bais-network
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '1'
          memory: 1G

  # Kibana (for log visualization)
  kibana:
    image: docker.elastic.co/kibana/kibana:8.10.0
    container_name: bais-kibana
    ports:
      - "5601:5601"
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
    networks:
      - bais-network
    depends_on:
      - elasticsearch
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '500m'
          memory: 512M

  # Logstash (for log processing)
  logstash:
    image: docker.elastic.co/logstash/logstash:8.10.0
    container_name: bais-logstash
    ports:
      - "5044:5044"
    volumes:
      - ./logstash.conf:/usr/share/logstash/pipeline/logstash.conf
      - app-logs:/app/logs:ro
    networks:
      - bais-network
    depends_on:
      - elasticsearch
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '500m'
          memory: 512M

# Networks
networks:
  bais-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

# Volumes
volumes:
  postgres-data:
    driver: local
  postgres-logs:
    driver: local
  redis-data:
    driver: local
  redis-logs:
    driver: local
  app-logs:
    driver: local
  app-tmp:
    driver: local
  prometheus-data:
    driver: local
  grafana-data:
    driver: local
  elasticsearch-data:
    driver: local
